# Triggers en Oracle


## üìö Contenido para Ense√±ar Triggers en Oracle

### 1\. Conceptos Fundamentales

  * **Definici√≥n:** ¬øQu√© es un **Trigger**? Es un bloque de c√≥digo PL/SQL o Java asociado a una tabla y que se ejecuta de manera **autom√°tica** e **impl√≠cita** cuando ocurre un evento espec√≠fico (DML o DDL) en la base de datos.
  * **Prop√≥sito Principal:** Aplicar reglas de negocio complejas, mantener la integridad referencial avanzada, registrar auditor√≠as y automatizar tareas.
  * **Eventos:** Tipos de operaciones que disparan un *trigger* (INSERT, UPDATE, DELETE en tablas; CREATE, ALTER, DROP en la base de datos).

-----

### 2\. Sintaxis y Componentes Clave

La sintaxis b√°sica de `CREATE TRIGGER` y sus partes esenciales:

  * **Momento del Disparo (`Timing`):**
      * `BEFORE`: Se ejecuta **antes** del evento (√∫til para validaciones o modificar datos).
      * `AFTER`: Se ejecuta **despu√©s** del evento (√∫til para auditor√≠a o acciones secundarias).
      * `INSTEAD OF`: Utilizado en **vistas** para realizar acciones en las tablas base.
  * **Nivel de Disparo (`Level`):**
      * `FOR EACH ROW`: El *trigger* se ejecuta una vez por **cada fila afectada** por el evento (el m√°s com√∫n).
      * `FOR EACH STATEMENT`: El *trigger* se ejecuta solo **una vez** por la sentencia SQL completa, sin importar cu√°ntas filas se vean afectadas.
  * **Cl√°usula `WHEN` (Opcional):** Permite especificar una **condici√≥n adicional** para que el *trigger* se dispare.
  * **Variables de Referencia (`:OLD` y `:NEW`):** Acceden a los valores de las filas **antes** (`:OLD`) y **despu√©s** (`:NEW`) de la modificaci√≥n (solo a nivel de fila).

-----

### 3\. Tipos de Triggers Comunes

  * **Triggers DML:** Se disparan por INSERT, UPDATE, o DELETE en tablas.
  * **Triggers DDL:** Se disparan por CREATE, ALTER, o DROP (√∫tiles para monitorear cambios en la estructura de la DB).
  * **Triggers de Sistema/Base de Datos:** Se disparan por eventos como `STARTUP`, `SHUTDOWN`, o un `LOGON` de usuario.

-----

### 4\. Consideraciones Pr√°cticas y Riesgos

  * **Orden de Ejecuci√≥n:** Oracle no garantiza un orden de ejecuci√≥n espec√≠fico si varios *triggers* del mismo tipo operan sobre la misma tabla y evento.
  * **Triggers Mutantes:** Se produce un error cuando un *trigger* a nivel de fila intenta leer o modificar la tabla que lo dispar√≥. Es crucial explicar c√≥mo evitar esto (por ejemplo, con *compound triggers* o *triggers* a nivel de sentencia).
  * **Rendimiento:** Un uso excesivo o mal dise√±ado de *triggers* puede afectar significativamente el rendimiento de la base de datos.

-----

## üìù Enunciado de Ejercicio para Laboratorio (Nivel Intermedio)

Este ejercicio es ideal para un laboratorio o evaluaci√≥n, ya que requiere crear tablas, insertar datos y aplicar un *trigger* de auditor√≠a.

### üéØ Objetivo del Ejercicio

Crear un **Trigger AFTER INSERT OR UPDATE** a nivel de fila que registre autom√°ticamente en una tabla de auditor√≠a (`LOG_EMPLEADOS`) los cambios de salario realizados a cualquier empleado, guardando el valor **antiguo** y el valor **nuevo** del salario, adem√°s de qui√©n y cu√°ndo se realiz√≥ el cambio.

### üõ†Ô∏è Pasos del Ejerciciow

#### 1\. Creaci√≥n de las Tablas (Prerrequisito)

```sql
-- 1. Tabla de Empleados
CREATE TABLE EMPLEADOS (
    empleado_id    NUMBER PRIMARY KEY,
    nombre         VARCHAR2(100) NOT NULL,
    salario        NUMBER(10, 2) DEFAULT 0
);

-- 2. Tabla de Auditor√≠a (Log)
CREATE TABLE LOG_EMPLEADOS (
    log_id         NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
    empleado_id    NUMBER NOT NULL,
    fecha_cambio   DATE DEFAULT SYSDATE,
    usuario        VARCHAR2(100) DEFAULT USER, -- Usuario que realiza la acci√≥n
    salario_anterior NUMBER(10, 2),
    salario_nuevo  NUMBER(10, 2),
    operacion      VARCHAR2(10) -- 'INSERT' o 'UPDATE'
);
```

#### 2\. Implementaci√≥n del Trigger (Soluci√≥n Esperada)

```sql
CREATE OR REPLACE TRIGGER trg_auditar_salario
AFTER INSERT OR UPDATE OF salario ON EMPLEADOS -- Se dispara solo si se modifica 'salario'
FOR EACH ROW -- Se ejecuta por cada fila afectada
BEGIN
    -- L√≥gica para registrar un INSERT
    IF INSERTING THEN
        INSERT INTO LOG_EMPLEADOS (empleado_id, salario_anterior, salario_nuevo, operacion)
        VALUES (:NEW.empleado_id, 0, :NEW.salario, 'INSERT');

    -- L√≥gica para registrar un UPDATE
    ELSIF UPDATING THEN
        -- Solo audita si el salario realmente ha cambiado
        IF :OLD.salario <> :NEW.salario THEN
            INSERT INTO LOG_EMPLEADOS (empleado_id, salario_anterior, salario_nuevo, operacion)
            VALUES (:OLD.empleado_id, :OLD.salario, :NEW.salario, 'UPDATE');
        END IF;
    END IF;
END;
/
```

#### 3\. Pruebas

```sql
-- a) Prueba de INSERT
INSERT INTO EMPLEADOS (empleado_id, nombre, salario) VALUES (101, 'Ana Lopez', 50000.00);

-- b) Prueba de UPDATE (cambio de salario)
UPDATE EMPLEADOS SET salario = 55000.00 WHERE empleado_id = 101;

-- c) Prueba de UPDATE (sin cambio de salario)
UPDATE EMPLEADOS SET nombre = 'Ana Mar√≠a L√≥pez' WHERE empleado_id = 101;

-- d) Verificaci√≥n del resultado
SELECT * FROM LOG_EMPLEADOS ORDER BY log_id;
```

-----

